Description: Add support for AppStream 0.6
 This allows compilation of Apper against the latest libappstream release.
Forwarded: yes
Author: Matthias Klumpp <matthias@tenstral.net>
Last-Update: 2014-04-14

diff --git a/libapper/AppStream.cpp b/libapper/AppStream.cpp
index 9786ccf..4c12c18 100644
--- a/libapper/AppStream.cpp
+++ b/libapper/AppStream.cpp
@@ -37,8 +37,10 @@ AppStream* AppStream::m_instance = 0;

 AppStream* AppStream::instance()
 {
-    if(!m_instance)
+    if(!m_instance) {
         m_instance = new AppStream(qApp);
+        m_instance->open();
+    }

     return m_instance;
 }
@@ -47,71 +49,114 @@ AppStream::AppStream(QObject *parent)
  : QObject(parent)
 {
 #ifdef HAVE_APPSTREAM
-    bool ret;
-
     // create new AppStream database and screenshot service
-    m_asDB = appstream_database_new();
-    m_asScreenshots = appstream_screenshot_service_new();
+    m_asDB = as_database_new();
+#endif //HAVE_APPSTREAM
+}
+
+AppStream::~AppStream()
+{
+#ifdef HAVE_APPSTREAM
+    g_object_unref(m_asDB);
+#endif
+}

-    ret = appstream_database_open(m_asDB);
+bool AppStream::open()
+{
+#ifdef HAVE_APPSTREAM
+    bool ret = as_database_open(m_asDB);
     if (!ret) {
         qWarning("Unable to open AppStream Xapian database!");
-        return;
+        return false;
     }

     // cache application data (we might use the db directly, later (making use of AppstreamSearchQuery))
-    GPtrArray *appArray = NULL;
-    appArray = appstream_database_get_all_applications(m_asDB);
+    GPtrArray *cptArray;
+    cptArray = as_database_get_all_components(m_asDB);
+    if (cptArray == NULL) {
+        qWarning("AppStream application array way NULL! (This should never happen)");
+        return false;
+    }

-    for (uint i = 0; i < appArray->len; i++) {
-        AppstreamAppInfo *appInfo;
-        appInfo = (AppstreamAppInfo*) g_ptr_array_index(appArray, i);
+    for (uint i = 0; i < cptArray->len; i++) {
+        AsComponent *cpt;
+        GPtrArray *sshot_array;
+        AsScreenshot *sshot;
+        cpt = (AsComponent*) g_ptr_array_index(cptArray, i);
+        // we only want desktop apps at time
+        if (as_component_get_kind (cpt) != AS_COMPONENT_KIND_DESKTOP_APP)
+            continue;

         Application app;
         // Application name
-        app.name = QString::fromUtf8(appstream_app_info_get_name(appInfo));
+        app.name = QString::fromUtf8(as_component_get_name(cpt));

         // Package name
-        QString pkgName = QString::fromUtf8(appstream_app_info_get_pkgname(appInfo));
+        QString pkgName = QString::fromUtf8(as_component_get_pkgname(cpt));

         // Desktop file
-        app.id = QString::fromUtf8(appstream_app_info_get_desktop_file(appInfo));
+        app.id = QString::fromUtf8(as_component_get_idname(cpt));

         // Summary
-        app.summary = QString::fromUtf8(appstream_app_info_get_summary(appInfo));
+        app.summary = QString::fromUtf8(as_component_get_summary(cpt));
+
+        // Description
+        app.description = QString::fromUtf8(as_component_get_description(cpt));

         // Application stock icon
-        app.icon = QString::fromUtf8(appstream_app_info_get_icon(appInfo));
+        app.icon = QString::fromUtf8(as_component_get_icon(cpt));

         // Application categories
-        int clen;
-        gchar **cats = appstream_app_info_get_categories(appInfo, &clen);
+        gchar **cats = as_component_get_categories(cpt);
         if (cats != NULL) {
             app.categories = QStringList();
-            for (int j = 0; j < clen; j++) {
+            for (int j = 0; cats[j] != NULL; j++) {
                 app.categories << QString::fromUtf8(cats[j]);
             }
         }
         g_strfreev(cats);

+        // add default screenshot urls
+        sshot_array = as_component_get_screenshots (cpt);
+
+        // find default screenshot, if possible
+        sshot = NULL;
+        for (uint i = 0; i < sshot_array->len; i++) {
+            sshot = (AsScreenshot*) g_ptr_array_index (sshot_array, 0);
+            if (as_screenshot_get_kind (sshot) == AS_SCREENSHOT_KIND_DEFAULT)
+                break;
+        }
+
+        if (sshot != NULL) {
+            GPtrArray *imgs;
+            imgs = as_screenshot_get_images (sshot);
+            for (uint i = 0; i < imgs->len; i++) {
+                AsImage *img;
+                img = (AsImage*) g_ptr_array_index (imgs, i);
+                if ((as_image_get_kind (img) == AS_IMAGE_KIND_SOURCE) && (app.screenshot.isEmpty())) {
+                    app.screenshot = QString::fromUtf8(as_image_get_url (img));
+                } else if ((as_image_get_kind (img) == AS_IMAGE_KIND_THUMBNAIL) && (app.thumbnail.isEmpty())) {
+                    app.thumbnail = QString::fromUtf8(as_image_get_url (img));
+                }
+
+                if ((!app.screenshot.isEmpty()) && (!app.thumbnail.isEmpty()))
+                    break;
+            }
+        }
+
         m_appInfo.insertMulti(pkgName, app);
     }
-    g_ptr_array_unref(appArray);
+    g_ptr_array_unref(cptArray);

-#endif //HAVE_APPSTREAM
-}
-
-AppStream::~AppStream()
-{
-#ifdef HAVE_APPSTREAM
-    g_object_unref(m_asDB);
-    g_object_unref(m_asScreenshots);
+    return true;
+#else
+    return false;
 #endif
 }

 QList<AppStream::Application> AppStream::applications(const QString &pkgName) const
 {
-    return m_appInfo.values(pkgName);;
+    return m_appInfo.values(pkgName);
 }

 QString AppStream::genericIcon(const QString &pkgName) const
@@ -146,8 +191,13 @@ QStringList AppStream::findPkgNames(const CategoryMatcher &parser) const
 QString AppStream::thumbnail(const QString &pkgName) const
 {
 #ifdef HAVE_APPSTREAM
-    const gchar *url = appstream_screenshot_service_get_thumbnail_url(m_asScreenshots, pkgName.toLatin1().data());
-    return QLatin1String(url);
+    QString url = "";
+    if (m_appInfo.contains(pkgName)) {
+        Application app = m_appInfo.value(pkgName);
+        url = app.thumbnail;
+    }
+
+    return url;
 #else
     Q_UNUSED(pkgName)
     return QString();
@@ -157,8 +207,13 @@ QString AppStream::thumbnail(const QString &pkgName) const
 QString AppStream::screenshot(const QString &pkgName) const
 {
 #ifdef HAVE_APPSTREAM
-    const gchar *url = appstream_screenshot_service_get_screenshot_url(m_asScreenshots, pkgName.toLatin1().data());
-    return QLatin1String(url);
+    QString url = "";
+    if (m_appInfo.contains(pkgName)) {
+        Application app = m_appInfo.value(pkgName);
+        url = app.screenshot;
+    }
+
+    return url;
 #else
     Q_UNUSED(pkgName)
     return QString();
diff --git a/libapper/AppStream.h b/libapper/AppStream.h
index c288543..2059ff4 100644
--- a/libapper/AppStream.h
+++ b/libapper/AppStream.h
@@ -29,23 +29,27 @@

 #include <kdemacros.h>

-struct _AppstreamDatabase;
-typedef struct _AppstreamDatabase AppstreamDatabase;
+struct _AsDatabase;
+typedef struct _AsDatabase AsDatabase;

-struct _AppstreamScreenshotService;
-typedef struct _AppstreamScreenshotService AppstreamScreenshotService;
+struct _AsScreenshotService;
+typedef struct _AsScreenshotService AsScreenshotService;

 class KDE_EXPORT AppStream : public QObject {
     public:
         struct Application {
             QString name;
             QString summary;
+            QString description;
             QString icon;
             QString id;
             QStringList categories;
+            QString screenshot;
+            QString thumbnail;
         };
         static AppStream* instance();
         virtual ~AppStream();
+        bool open();

         QList<Application> applications(const QString &pkgName) const;
         QString genericIcon(const QString &pkgName) const;
@@ -55,8 +59,7 @@ class KDE_EXPORT AppStream : public QObject {

     private:
         explicit AppStream(QObject *parent = 0);
-        AppstreamDatabase *m_asDB;
-	AppstreamScreenshotService *m_asScreenshots;
+        AsDatabase *m_asDB;

         QHash<QString, Application> m_appInfo;
         static AppStream         *m_instance;
diff --git a/libapper/CMakeLists.txt b/libapper/CMakeLists.txt
index e156419..cb040cc 100644
--- a/libapper/CMakeLists.txt
+++ b/libapper/CMakeLists.txt
@@ -33,7 +33,7 @@ set(libapper_SRCS

 if(APPSTREAM)
     pkg_check_modules(GLIB2 REQUIRED glib-2.0>=2.36)
-    pkg_check_modules(APPSTREAM REQUIRED appstream>=0.3.1)
+    pkg_check_modules(APPSTREAM REQUIRED appstream>=0.6)

     set(libapper_SRCS ${libapper_SRCS} AppStream.cpp)
 endif()
